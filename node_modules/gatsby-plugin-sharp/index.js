"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const sharp = require(`./safe-sharp`);

const imageSize = require(`probe-image-size`);

const _ = require(`lodash`);

const fs = require(`fs-extra`);

const path = require(`path`);

const _require = require(`./scheduler`),
      scheduleJob = _require.scheduleJob;

const _require2 = require(`./process-file`),
      createArgsDigest = _require2.createArgsDigest;

const _require3 = require(`./report-error`),
      reportError = _require3.reportError;

const _require4 = require(`./plugin-options`),
      getPluginOptions = _require4.getPluginOptions,
      healOptions = _require4.healOptions;

const _require5 = require(`./trace-svg`),
      memoizedTraceSVG = _require5.memoizedTraceSVG;

const imageSizeCache = new Map();

const getImageSize = file => {
  if (process.env.NODE_ENV !== `test` && imageSizeCache.has(file.internal.contentDigest)) {
    return imageSizeCache.get(file.internal.contentDigest);
  } else {
    const dimensions = imageSize.sync(toArray(fs.readFileSync(file.absolutePath)));
    imageSizeCache.set(file.internal.contentDigest, dimensions);
    return dimensions;
  }
};

const duotone = require(`./duotone`); // Bound action creators should be set when passed to onPreInit in gatsby-node.
// ** It is NOT safe to just directly require the gatsby module **.
// There is no guarantee that the module resolved is the module executing!
// This can occur in mono repos depending on how dependencies have been hoisted.
// The direct require has been left only to avoid breaking changes.


let _require6 = require(`gatsby/dist/redux/actions`),
    boundActionCreators = _require6.boundActionCreators;

exports.setBoundActionCreators = actions => {
  boundActionCreators = actions;
}; // We set the queue to a Map instead of an array to easily search in onCreateDevServer Api hook


const queue = new Map();
exports.queue = queue;

function queueImageResizing({
  file,
  args = {},
  reporter
}) {
  const pluginOptions = getPluginOptions();
  const options = healOptions(pluginOptions, args, file.extension);

  if (!options.toFormat) {
    options.toFormat = file.extension;
  }

  const argsDigestShort = createArgsDigest(options);
  const imgSrc = `/${file.name}.${options.toFormat}`;
  const dirPath = path.join(process.cwd(), `public`, `static`, file.internal.contentDigest, argsDigestShort);
  const filePath = path.join(dirPath, imgSrc);
  fs.ensureDirSync(dirPath);
  let width;
  let height; // Calculate the eventual width/height of the image.

  const dimensions = getImageSize(file);
  let aspectRatio = dimensions.width / dimensions.height;
  const originalName = file.base; // If the width/height are both set, we're cropping so just return
  // that.

  if (options.width && options.height) {
    width = options.width;
    height = options.height; // Recalculate the aspectRatio for the cropped photo

    aspectRatio = width / height;
  } else if (options.width) {
    // Use the aspect ratio of the image to calculate what will be the resulting
    // height.
    width = options.width;
    height = Math.round(options.width / aspectRatio);
  } else {
    // Use the aspect ratio of the image to calculate what will be the resulting
    // width.
    height = options.height;
    width = Math.round(options.height * aspectRatio);
  } // encode the file name for URL


  const encodedImgSrc = `/${encodeURIComponent(file.name)}.${options.toFormat}`; // Prefix the image src.

  const digestDirPrefix = `${file.internal.contentDigest}/${argsDigestShort}`;
  const prefixedSrc = options.pathPrefix + `/static/${digestDirPrefix}` + encodedImgSrc; // Create job and add it to the queue, the queue will be processed inside gatsby-node.js

  const job = {
    args: options,
    inputPath: file.absolutePath,
    outputPath: filePath
  };
  queue.set(prefixedSrc, job); // schedule job immediately - this will be changed when image processing on demand is implemented

  const finishedPromise = scheduleJob(job, boundActionCreators, pluginOptions).then(() => {
    queue.delete(prefixedSrc);
  });
  return {
    src: prefixedSrc,
    absolutePath: filePath,
    width,
    height,
    aspectRatio,
    finishedPromise,
    // // finishedPromise is needed to not break our API (https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-transformer-sqip/src/extend-node-type.js#L115)
    // finishedPromise: {
    //   then: (resolve, reject) => {
    //     scheduleJob(job, boundActionCreators, pluginOptions).then(() => {
    //       queue.delete(prefixedSrc)
    //       resolve()
    //     }, reject)
    //   },
    // },
    originalName: originalName
  };
} // A value in pixels(Int)


const defaultBase64Width = () => getPluginOptions().base64Width || 20;

function generateBase64(_x) {
  return _generateBase.apply(this, arguments);
}

function _generateBase() {
  _generateBase = (0, _asyncToGenerator2.default)(function* ({
    file,
    args,
    reporter
  }) {
    const pluginOptions = getPluginOptions();
    const options = healOptions(pluginOptions, args, file.extension, {
      width: defaultBase64Width()
    });
    let pipeline;

    try {
      pipeline = sharp(file.absolutePath).rotate();
    } catch (err) {
      reportError(`Failed to process image ${file.absolutePath}`, err, reporter);
      return null;
    }

    const forceBase64Format = args.toFormatBase64 || pluginOptions.forceBase64Format;

    if (forceBase64Format) {
      args.toFormat = forceBase64Format;
    }

    pipeline.resize(options.width, options.height, {
      position: options.cropFocus
    }).png({
      compressionLevel: options.pngCompressionLevel,
      adaptiveFiltering: false,
      force: args.toFormat === `png`
    }).jpeg({
      quality: options.quality,
      progressive: options.jpegProgressive,
      force: args.toFormat === `jpg`
    }).webp({
      quality: options.quality,
      force: args.toFormat === `webp`
    }); // grayscale

    if (options.grayscale) {
      pipeline = pipeline.grayscale();
    } // rotate


    if (options.rotate && options.rotate !== 0) {
      pipeline = pipeline.rotate(options.rotate);
    } // duotone


    if (options.duotone) {
      pipeline = yield duotone(options.duotone, args.toFormat, pipeline);
    }

    const _ref3 = yield pipeline.toBuffer({
      resolveWithObject: true
    }),
          buffer = _ref3.data,
          info = _ref3.info;

    const base64output = {
      src: `data:image/${info.format};base64,${buffer.toString(`base64`)}`,
      width: info.width,
      height: info.height,
      aspectRatio: info.width / info.height,
      originalName: file.base
    };
    return base64output;
  });
  return _generateBase.apply(this, arguments);
}

const base64CacheKey = ({
  file,
  args
}) => `${file.id}${JSON.stringify(args)}`;

const memoizedBase64 = _.memoize(generateBase64, base64CacheKey);

const cachifiedBase64 =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* (_ref2) {
    let cache = _ref2.cache,
        arg = (0, _objectWithoutPropertiesLoose2.default)(_ref2, ["cache"]);
    const cacheKey = base64CacheKey(arg);
    const cachedBase64 = yield cache.get(cacheKey);

    if (cachedBase64) {
      return cachedBase64;
    }

    const base64output = yield generateBase64(arg);
    yield cache.set(cacheKey, base64output);
    return base64output;
  });

  return function cachifiedBase64(_x2) {
    return _ref.apply(this, arguments);
  };
}();

function base64(_x3) {
  return _base.apply(this, arguments);
}

function _base() {
  _base = (0, _asyncToGenerator2.default)(function* (arg) {
    if (arg.cache) {
      // Not all tranformer plugins are going to provide cache
      return yield cachifiedBase64(arg);
    }

    return yield memoizedBase64(arg);
  });
  return _base.apply(this, arguments);
}

function getTracedSVG(_x4, _x5) {
  return _getTracedSVG.apply(this, arguments);
}

function _getTracedSVG() {
  _getTracedSVG = (0, _asyncToGenerator2.default)(function* (options, file) {
    if (options.generateTracedSVG && options.tracedSVG) {
      const tracedSVG = yield traceSVG({
        file,
        args: options.tracedSVG,
        fileArgs: options
      });
      return tracedSVG;
    }

    return undefined;
  });
  return _getTracedSVG.apply(this, arguments);
}

function fluid(_x6) {
  return _fluid.apply(this, arguments);
}

function _fluid() {
  _fluid = (0, _asyncToGenerator2.default)(function* ({
    file,
    args = {},
    reporter,
    cache
  }) {
    const options = healOptions(getPluginOptions(), args, file.extension);

    if (options.sizeByPixelDensity) {
      /*
       * We learned that `sizeByPixelDensity` is only valid for vector images,
       * and Gatsby’s implementation of Sharp doesn’t support vector images.
       * This means we should remove this option in the next major version of
       * Gatsby, but for now we can no-op and warn.
       *
       * See https://github.com/gatsbyjs/gatsby/issues/12743
       *
       * TODO: remove the sizeByPixelDensity option in the next breaking release
       */
      reporter.warn(`the option sizeByPixelDensity is deprecated and should not be used. It will be removed in the next major release of Gatsby.`);
    } // Account for images with a high pixel density. We assume that these types of
    // images are intended to be displayed at their native resolution.


    let metadata;

    try {
      metadata = yield sharp(file.absolutePath).metadata();
    } catch (err) {
      reportError(`Failed to process image ${file.absolutePath}`, err, reporter);
      return null;
    }

    const _metadata = metadata,
          width = _metadata.width,
          height = _metadata.height,
          density = _metadata.density,
          format = _metadata.format; // if no maxWidth is passed, we need to resize the image based on the passed maxHeight

    const fixedDimension = options.maxWidth === undefined ? `maxHeight` : `maxWidth`;

    if (options[fixedDimension] < 1) {
      throw new Error(`${fixedDimension} has to be a positive int larger than zero (> 0), now it's ${options[fixedDimension]}`);
    }

    let presentationWidth, presentationHeight;

    if (fixedDimension === `maxWidth`) {
      presentationWidth = Math.min(options.maxWidth, width);
      presentationHeight = Math.round(presentationWidth * (height / width));
    } else {
      presentationHeight = Math.min(options.maxHeight, height);
      presentationWidth = Math.round(presentationHeight * (width / height));
    } // If the users didn't set default sizes, we'll make one.


    if (!options.sizes) {
      options.sizes = `(max-width: ${presentationWidth}px) 100vw, ${presentationWidth}px`;
    } // Create sizes (in width) for the image if no custom breakpoints are
    // provided. If the max width of the container for the rendered markdown file
    // is 800px, the sizes would then be: 200, 400, 800, 1200, 1600, 2400.
    //
    // This is enough sizes to provide close to the optimal image size for every
    // device size / screen resolution while (hopefully) not requiring too much
    // image processing time (Sharp has optimizations thankfully for creating
    // multiple sizes of the same input file)


    const fluidSizes = [options[fixedDimension]];

    // use standard breakpoints if no custom breakpoints are specified
    if (!options.srcSetBreakpoints || !options.srcSetBreakpoints.length) {
      fluidSizes.push(options[fixedDimension] / 4);
      fluidSizes.push(options[fixedDimension] / 2);
      fluidSizes.push(options[fixedDimension] * 1.5);
      fluidSizes.push(options[fixedDimension] * 2);
      fluidSizes.push(options[fixedDimension] * 3);
    } else {
      options.srcSetBreakpoints.forEach(breakpoint => {
        if (breakpoint < 1) {
          throw new Error(`All ints in srcSetBreakpoints should be positive ints larger than zero (> 0), found ${breakpoint}`);
        } // ensure no duplicates are added


        if (fluidSizes.includes(breakpoint)) {
          return;
        }

        fluidSizes.push(breakpoint);
      });
    }

    const filteredSizes = fluidSizes.filter(size => size < (fixedDimension === `maxWidth` ? width : height)); // Add the original image to ensure the largest image possible
    // is available for small images. Also so we can link to
    // the original image.

    filteredSizes.push(fixedDimension === `maxWidth` ? width : height); // Sort sizes for prettiness.

    const sortedSizes = _.sortBy(filteredSizes); // Queue sizes for processing.


    const dimensionAttr = fixedDimension === `maxWidth` ? `width` : `height`;
    const otherDimensionAttr = fixedDimension === `maxWidth` ? `height` : `width`;
    const images = sortedSizes.map(size => {
      const arrrgs = Object.assign({}, options, {
        [otherDimensionAttr]: undefined,
        [dimensionAttr]: Math.round(size) // Queue sizes for processing.

      });

      if (options.maxWidth !== undefined && options.maxHeight !== undefined) {
        arrrgs.height = Math.round(size * (options.maxHeight / options.maxWidth));
      }

      return queueImageResizing({
        file,
        args: arrrgs,
        // matey
        reporter
      });
    });
    let base64Image;

    if (options.base64) {
      const base64Width = options.base64Width || defaultBase64Width();
      const base64Height = Math.max(1, Math.round(base64Width * height / width));
      const base64Args = {
        duotone: options.duotone,
        grayscale: options.grayscale,
        rotate: options.rotate,
        toFormat: options.toFormat,
        toFormatBase64: options.toFormatBase64,
        width: base64Width,
        height: base64Height // Get base64 version

      };
      base64Image = yield base64({
        file,
        args: base64Args,
        reporter,
        cache
      });
    }

    const tracedSVG = yield getTracedSVG(options, file); // Construct src and srcSet strings.

    const originalImg = _.maxBy(images, image => image.width).src;

    const fallbackSrc = _.minBy(images, image => Math.abs(options[fixedDimension] - image[dimensionAttr])).src;

    const srcSet = images.map(image => `${image.src} ${Math.round(image.width)}w`).join(`,\n`);
    const originalName = file.base; // figure out the srcSet format

    let srcSetType = `image/${format}`;

    if (options.toFormat) {
      switch (options.toFormat) {
        case `png`:
          srcSetType = `image/png`;
          break;

        case `jpg`:
          srcSetType = `image/jpeg`;
          break;

        case `webp`:
          srcSetType = `image/webp`;
          break;

        case ``:
        case `no_change`:
        default:
          break;
      }
    }

    return {
      base64: base64Image && base64Image.src,
      aspectRatio: images[0].aspectRatio,
      src: fallbackSrc,
      srcSet,
      srcSetType,
      sizes: options.sizes,
      originalImg: originalImg,
      originalName: originalName,
      density,
      presentationWidth,
      presentationHeight,
      tracedSVG
    };
  });
  return _fluid.apply(this, arguments);
}

function fixed(_x7) {
  return _fixed.apply(this, arguments);
}

function _fixed() {
  _fixed = (0, _asyncToGenerator2.default)(function* ({
    file,
    args = {},
    reporter,
    cache
  }) {
    const options = healOptions(getPluginOptions(), args, file.extension); // if no width is passed, we need to resize the image based on the passed height

    const fixedDimension = options.width === undefined ? `height` : `width`; // Create sizes for different resolutions — we do 1x, 1.5x, 2x, and 3x.

    const sizes = [];
    sizes.push(options[fixedDimension]);
    sizes.push(options[fixedDimension] * 1.5);
    sizes.push(options[fixedDimension] * 2);
    sizes.push(options[fixedDimension] * 3);
    const dimensions = getImageSize(file);
    const filteredSizes = sizes.filter(size => size <= dimensions[fixedDimension]); // If there's no fluid images after filtering (e.g. image is smaller than what's
    // requested, add back the original so there's at least something)

    if (filteredSizes.length === 0) {
      filteredSizes.push(dimensions[fixedDimension]);
      console.warn(`
                 The requested ${fixedDimension} "${options[fixedDimension]}px" for a resolutions field for
                 the file ${file.absolutePath}
                 was larger than the actual image ${fixedDimension} of ${dimensions[fixedDimension]}px!
                 If possible, replace the current image with a larger one.
                 `);
    } // Sort images for prettiness.


    const sortedSizes = _.sortBy(filteredSizes);

    const images = sortedSizes.map(size => {
      const arrrgs = Object.assign({}, options, {
        [fixedDimension]: Math.round(size) // Queue images for processing.

      });

      if (options.width !== undefined && options.height !== undefined) {
        arrrgs.height = Math.round(size * (options.height / options.width));
      }

      return queueImageResizing({
        file,
        args: arrrgs,
        reporter
      });
    });
    let base64Image;

    if (options.base64) {
      const base64Args = {
        // height is adjusted accordingly with respect to the aspect ratio
        width: options.base64Width,
        duotone: options.duotone,
        grayscale: options.grayscale,
        rotate: options.rotate,
        toFormat: options.toFormat,
        toFormatBase64: options.toFormatBase64 // Get base64 version

      };
      base64Image = yield base64({
        file,
        args: base64Args,
        reporter,
        cache
      });
    }

    const tracedSVG = yield getTracedSVG(options, file);
    const fallbackSrc = images[0].src;
    const srcSet = images.map((image, i) => {
      let resolution;

      switch (i) {
        case 0:
          resolution = `1x`;
          break;

        case 1:
          resolution = `1.5x`;
          break;

        case 2:
          resolution = `2x`;
          break;

        case 3:
          resolution = `3x`;
          break;

        default:
      }

      return `${image.src} ${resolution}`;
    }).join(`,\n`);
    const originalName = file.base;
    return {
      base64: base64Image && base64Image.src,
      aspectRatio: images[0].aspectRatio,
      width: images[0].width,
      height: images[0].height,
      src: fallbackSrc,
      srcSet,
      originalName: originalName,
      tracedSVG
    };
  });
  return _fixed.apply(this, arguments);
}

function traceSVG(_x8) {
  return _traceSVG.apply(this, arguments);
}

function _traceSVG() {
  _traceSVG = (0, _asyncToGenerator2.default)(function* (args) {
    return yield memoizedTraceSVG(args);
  });
  return _traceSVG.apply(this, arguments);
}

function toArray(buf) {
  var arr = new Array(buf.length);

  for (var i = 0; i < buf.length; i++) {
    arr[i] = buf[i];
  }

  return arr;
}

exports.queueImageResizing = queueImageResizing;
exports.resize = queueImageResizing;
exports.base64 = base64;
exports.traceSVG = traceSVG;
exports.sizes = fluid;
exports.resolutions = fixed;
exports.fluid = fluid;
exports.fixed = fixed;
exports.getImageSize = getImageSize;