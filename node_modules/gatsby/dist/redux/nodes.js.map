{"version":3,"sources":["../../src/redux/nodes.js"],"names":["store","require","getNodes","nodes","getState","Array","from","values","exports","getNode","id","get","getNodesByType","type","nodesByType","getTypes","keys","hasNodeChanged","digest","node","internal","contentDigest","getNodeAndSavePathDependency","path","nodeId","saveResolvedNodes","nodeTypeNames","resolver","typeName","resolvedNodes","Map","resolved","set","dispatch","payload","key","getResolvedNode","resolvedNodesCache","__gatsby_resolved","addResolvedNodes","arr","forEach","push","ensureIndexByTypedChain","chain","typedKeyValueIndexes","chained","join","nodeTypeNamePrefix","typedKey","byKeyValue","includes","v","i","length","nextProp","Set","add","getNodesByTypedChain","value","byTypedKey"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport { createPageDependency } from \"./actions/add-page-dependency\"\nconst { store } = require(`./index`)\n\n/**\n * Get all nodes from redux store.\n *\n * @returns {Array}\n */\nconst getNodes = () => {\n  const nodes = store.getState().nodes\n  if (nodes) {\n    return Array.from(nodes.values())\n  } else {\n    return []\n  }\n}\n\nexports.getNodes = getNodes\n\n/** Get node by id from store.\n *\n * @param {string} id\n * @returns {Object}\n */\nconst getNode = id => store.getState().nodes.get(id)\n\nexports.getNode = getNode\n\n/**\n * Get all nodes of type from redux store.\n *\n * @param {string} type\n * @returns {Array}\n */\nconst getNodesByType = type => {\n  const nodes = store.getState().nodesByType.get(type)\n  if (nodes) {\n    return Array.from(nodes.values())\n  } else {\n    return []\n  }\n}\n\nexports.getNodesByType = getNodesByType\n\n/**\n * Get all type names from redux store.\n *\n * @returns {Array}\n */\nconst getTypes = () => Array.from(store.getState().nodesByType.keys())\n\nexports.getTypes = getTypes\n\n/**\n * Determine if node has changed.\n *\n * @param {string} id\n * @param {string} digest\n * @returns {boolean}\n */\nexports.hasNodeChanged = (id, digest) => {\n  const node = store.getState().nodes.get(id)\n  if (!node) {\n    return true\n  } else {\n    return node.internal.contentDigest !== digest\n  }\n}\n\n/**\n * Get node and save path dependency.\n *\n * @param {string} id\n * @param {string} path\n * @returns {Object} node\n */\nexports.getNodeAndSavePathDependency = (id, path) => {\n  const node = getNode(id)\n  createPageDependency({ path, nodeId: id })\n  return node\n}\n\nexports.saveResolvedNodes = async (nodeTypeNames, resolver) => {\n  for (const typeName of nodeTypeNames) {\n    const nodes = store.getState().nodesByType.get(typeName)\n    const resolvedNodes = new Map()\n    if (nodes) {\n      for (const node of nodes.values()) {\n        const resolved = await resolver(node)\n        resolvedNodes.set(node.id, resolved)\n      }\n      store.dispatch({\n        type: `SET_RESOLVED_NODES`,\n        payload: {\n          key: typeName,\n          nodes: resolvedNodes,\n        },\n      })\n    }\n  }\n}\n\n/**\n * Get node and save path dependency.\n *\n * @param {string} typeName\n * @param {string} id\n * @returns {Object|void} node\n */\nconst getResolvedNode = (typeName, id) => {\n  const { nodesByType, resolvedNodesCache } = store.getState()\n  const nodes /*: Map<mixed> */ = nodesByType.get(typeName)\n\n  if (!nodes) {\n    return null\n  }\n\n  let node = nodes.get(id)\n\n  if (!node) {\n    return null\n  }\n\n  const resolvedNodes = resolvedNodesCache.get(typeName)\n\n  if (resolvedNodes) {\n    node.__gatsby_resolved = resolvedNodes.get(id)\n  }\n\n  return node\n}\n\nexports.getResolvedNode = getResolvedNode\n\nconst addResolvedNodes = (typeName, arr) => {\n  const { nodesByType, resolvedNodesCache } = store.getState()\n  const nodes /*: Map<mixed> */ = nodesByType.get(typeName)\n\n  if (!nodes) {\n    return\n  }\n\n  const resolvedNodes = resolvedNodesCache.get(typeName)\n\n  nodes.forEach(node => {\n    if (resolvedNodes) {\n      node.__gatsby_resolved = resolvedNodes.get(node.id)\n    }\n    arr.push(node)\n  })\n}\n\nexports.addResolvedNodes = addResolvedNodes\n\n/**\n * Given a (\"flat\") filter path leading up to \"eq\", a set of node types, and a\n * cache, create a cache that for each resulting value of the filter contains\n * all the Nodes in a Set (or, if the property is `id`, just the Nodes).\n * This cache is used for applying the filter and is a massive improvement over\n * looping over all the nodes, when the number of pages (/nodes) scale up.\n *\n * @param {Array<string>} chain\n * @param {Array<string>} nodeTypeNames\n * @param {undefined | Map<string, Map<string | number | boolean, Node>>} typedKeyValueIndexes\n *   This object lives in query/query-runner.js and is passed down runQuery\n * @returns {undefined}\n */\nconst ensureIndexByTypedChain = (\n  chain,\n  nodeTypeNames,\n  typedKeyValueIndexes\n) => {\n  const chained = chain.join(`+`)\n\n  const nodeTypeNamePrefix = nodeTypeNames.join(`,`) + `/`\n  // The format of the typedKey is `type,type/path+to+eqobj`\n  const typedKey = nodeTypeNamePrefix + chained\n\n  let byKeyValue = typedKeyValueIndexes.get(typedKey)\n  if (byKeyValue) {\n    return\n  }\n\n  const { nodes, resolvedNodesCache } = store.getState()\n\n  byKeyValue = new Map() // Map<node.value, Set<all nodes with this value for this key>>\n  typedKeyValueIndexes.set(typedKey, byKeyValue)\n\n  nodes.forEach(node => {\n    if (!nodeTypeNames.includes(node.internal.type)) {\n      return\n    }\n\n    // There can be a filter that targets `__gatsby_resolved` so fix that first\n    if (!node.__gatsby_resolved) {\n      const typeName = node.internal.type\n      const resolvedNodes = resolvedNodesCache.get(typeName)\n      node.__gatsby_resolved = resolvedNodes?.get(node.id)\n    }\n\n    let v = node\n    let i = 0\n    while (i < chain.length && v) {\n      const nextProp = chain[i++]\n      v = v[nextProp]\n    }\n\n    if (\n      (typeof v !== `string` &&\n        typeof v !== `number` &&\n        typeof v !== `boolean`) ||\n      i !== chain.length\n    ) {\n      // Not sure whether this is supposed to happen, but this means that either\n      // - The node chain ended with `undefined`, or\n      // - The node chain ended in something other than a primitive, or\n      // - A part in the chain in the object was not an object\n      return\n    }\n\n    // Special case `id` as that bucket never receives more than one element\n    if (chained === `id`) {\n      // Note: this is not a duplicate from `nodes` because this set only\n      //       contains nodes of this type. Page nodes are a subset of all nodes\n      byKeyValue.set(v, node)\n      return\n    }\n\n    let set = byKeyValue.get(v)\n    if (!set) {\n      set = new Set()\n      byKeyValue.set(v, set)\n    }\n    set.add(node)\n  })\n}\n\nexports.ensureIndexByTypedChain = ensureIndexByTypedChain\n\n/**\n * Given a (\"flat\") filter path leading up to \"eq\", a target value to filter\n * for, a set of node types, and a pre-generated lookup cache, return the set\n * of Nodes (or, if the property is `id` just the Node) which pass the filter.\n * This returns `undefined` if there is Node that passes the filter.\n *\n * Basically if the filter was {a: {b: {slug: {eq: \"foo/bar\"}}}} then it will\n * return all the nodes that have `node.slug === \"foo/bar\"`. That usually (but\n * not always) at most one node for slug, but this filter can apply to anything.\n *\n * The only exception is `id`, since internally there can be at most one node\n * per `id` so there's a minor optimization for that (no need for Sets).\n *\n * @param {Array<string>} chain Note: `eq` is assumed to be the leaf prop here\n * @param {boolean | number | string} value This is the value being filtered for\n * @param {Array<string>} nodeTypeNames\n * @param {undefined | Map<string, Map<string | number | boolean, Node>>} typedKeyValueIndexes\n *   This object lives in query/query-runner.js and is passed down runQuery\n * @returns {Array<Node> | undefined}\n */\nconst getNodesByTypedChain = (\n  chain,\n  value,\n  nodeTypeNames,\n  typedKeyValueIndexes\n) => {\n  const key = chain.join(`+`)\n\n  const typedKey = nodeTypeNames.join(`,`) + `/` + key\n\n  let byTypedKey = typedKeyValueIndexes?.get(typedKey)\n  return byTypedKey?.get(value)\n}\n\nexports.getNodesByTypedChain = getNodesByTypedChain\n"],"file":"nodes.js"}