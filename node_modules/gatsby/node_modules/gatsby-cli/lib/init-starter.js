"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.initStarter = initStarter;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _betterOpn = _interopRequireDefault(require("better-opn"));

var _child_process = require("child_process");

var _execa = _interopRequireDefault(require("execa"));

var _fsExistsCached = require("fs-exists-cached");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _gatsbyTelemetry = require("gatsby-telemetry");

var _hostedGitInfo = _interopRequireDefault(require("hosted-git-info"));

var _isValidPath = _interopRequireDefault(require("is-valid-path"));

var _path = _interopRequireDefault(require("path"));

var _prompts = _interopRequireDefault(require("prompts"));

var _url = _interopRequireDefault(require("url"));

var _reporter = _interopRequireDefault(require("./reporter"));

var _packageManager = require("./util/package-manager");

var _isTty = _interopRequireDefault(require("./util/is-tty"));

const spawnWithArgs = (file, args, options) => (0, _execa.default)(file, args, Object.assign({
  stdio: `inherit`,
  preferLocal: false
}, options));

const spawn = (cmd, options) => {
  const _cmd$split = cmd.split(/\s+/),
        file = _cmd$split[0],
        args = _cmd$split.slice(1);

  return spawnWithArgs(file, args, options);
}; // Checks the existence of yarn package and user preference if it exists
// We use yarnpkg instead of yarn to avoid conflict with Hadoop yarn
// Refer to https://github.com/yarnpkg/yarn/issues/673


const shouldUseYarn =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* () {
    try {
      (0, _child_process.execSync)(`yarnpkg --version`, {
        stdio: `ignore`
      });
      let packageManager = (0, _packageManager.getPackageManager)();

      if (!packageManager) {
        // if package manager is not set:
        //  - prompt user to pick package manager if in interactive console
        //  - default to yarn if not in interactive console
        if ((0, _isTty.default)()) {
          packageManager = (yield (0, _packageManager.promptPackageManager)()) || `yarn`;
        } else {
          packageManager = `yarn`;
        }
      }

      return packageManager === `yarn`;
    } catch (e) {
      return false;
    }
  });

  return function shouldUseYarn() {
    return _ref.apply(this, arguments);
  };
}();

const isAlreadyGitRepository =
/*#__PURE__*/
function () {
  var _ref2 = (0, _asyncToGenerator2.default)(function* () {
    try {
      return yield spawn(`git rev-parse --is-inside-work-tree`, {
        stdio: `pipe`
      }).then(output => output.stdout === `true`);
    } catch (err) {
      return false;
    }
  });

  return function isAlreadyGitRepository() {
    return _ref2.apply(this, arguments);
  };
}(); // Initialize newly cloned directory as a git repo


const gitInit =
/*#__PURE__*/
function () {
  var _ref3 = (0, _asyncToGenerator2.default)(function* (rootPath) {
    _reporter.default.info(`Initialising git in ${rootPath}`);

    return yield spawn(`git init`, {
      cwd: rootPath
    });
  });

  return function gitInit(_x) {
    return _ref3.apply(this, arguments);
  };
}(); // Create a .gitignore file if it is missing in the new directory


const maybeCreateGitIgnore =
/*#__PURE__*/
function () {
  var _ref4 = (0, _asyncToGenerator2.default)(function* (rootPath) {
    if ((0, _fsExistsCached.sync)(_path.default.join(rootPath, `.gitignore`))) {
      return;
    }

    _reporter.default.info(`Creating minimal .gitignore in ${rootPath}`);

    yield _fsExtra.default.writeFile(_path.default.join(rootPath, `.gitignore`), `.cache\nnode_modules\npublic\n`);
  });

  return function maybeCreateGitIgnore(_x2) {
    return _ref4.apply(this, arguments);
  };
}(); // Create an initial git commit in the new directory


const createInitialGitCommit =
/*#__PURE__*/
function () {
  var _ref5 = (0, _asyncToGenerator2.default)(function* (rootPath, starterUrl) {
    _reporter.default.info(`Create initial git commit in ${rootPath}`);

    yield spawn(`git add -A`, {
      cwd: rootPath
    }); // use execSync instead of spawn to handle git clients using
    // pgp signatures (with password)

    try {
      (0, _child_process.execSync)(`git commit -m "Initial commit from gatsby: (${starterUrl})"`, {
        cwd: rootPath
      });
    } catch (_unused) {
      // Remove git support if initial commit fails
      _reporter.default.info(`Initial git commit failed - removing git support\n`);

      _fsExtra.default.removeSync(_path.default.join(rootPath, `.git`));
    }
  });

  return function createInitialGitCommit(_x3, _x4) {
    return _ref5.apply(this, arguments);
  };
}(); // Executes `npm install` or `yarn install` in rootPath.


const install =
/*#__PURE__*/
function () {
  var _ref6 = (0, _asyncToGenerator2.default)(function* (rootPath) {
    const prevDir = process.cwd();

    _reporter.default.info(`Installing packages...`);

    process.chdir(rootPath);

    try {
      if (yield shouldUseYarn()) {
        yield _fsExtra.default.remove(`package-lock.json`);
        yield spawn(`yarnpkg`);
      } else {
        yield _fsExtra.default.remove(`yarn.lock`);
        yield spawn(`npm install`);
      }
    } finally {
      process.chdir(prevDir);
    }
  });

  return function install(_x5) {
    return _ref6.apply(this, arguments);
  };
}();

const ignored = path => !/^\.(git|hg)$/.test(_path.default.basename(path)); // Copy starter from file system.


const copy =
/*#__PURE__*/
function () {
  var _ref7 = (0, _asyncToGenerator2.default)(function* (starterPath, rootPath) {
    // Chmod with 755.
    // 493 = parseInt('755', 8)
    yield _fsExtra.default.ensureDir(rootPath, {
      mode: 493
    });

    if (!(0, _fsExistsCached.sync)(starterPath)) {
      throw new Error(`starter ${starterPath} doesn't exist`);
    }

    if (starterPath === `.`) {
      throw new Error(`You can't create a starter from the existing directory. If you want to
      create a new site in the current directory, the trailing dot isn't
      necessary. If you want to create a new site from a local starter, run
      something like "gatsby new new-gatsby-site ../my-gatsby-starter"`);
    }

    _reporter.default.info(`Creating new site from local starter: ${starterPath}`);

    _reporter.default.log(`Copying local starter to ${rootPath} ...`);

    yield _fsExtra.default.copy(starterPath, rootPath, {
      filter: ignored
    });

    _reporter.default.success(`Created starter directory layout`);

    yield install(rootPath);
    return true;
  });

  return function copy(_x6, _x7) {
    return _ref7.apply(this, arguments);
  };
}(); // Clones starter from URI.


const clone =
/*#__PURE__*/
function () {
  var _ref8 = (0, _asyncToGenerator2.default)(function* (hostInfo, rootPath) {
    let url; // Let people use private repos accessed over SSH.

    if (hostInfo.getDefaultRepresentation() === `sshurl`) {
      url = hostInfo.ssh({
        noCommittish: true
      }); // Otherwise default to normal git syntax.
    } else {
      url = hostInfo.https({
        noCommittish: true,
        noGitPlus: true
      });
    }

    const branch = hostInfo.committish ? [`-b`, hostInfo.committish] : [];

    _reporter.default.info(`Creating new site from git: ${url}`);

    const args = [`clone`, ...branch, url, rootPath, `--depth=1`].filter(arg => Boolean(arg));
    yield spawnWithArgs(`git`, args);

    _reporter.default.success(`Created starter directory layout`);

    yield _fsExtra.default.remove(_path.default.join(rootPath, `.git`));
    yield install(rootPath);
    const isGit = yield isAlreadyGitRepository();
    if (!isGit) yield gitInit(rootPath);
    yield maybeCreateGitIgnore(rootPath);
    if (!isGit) yield createInitialGitCommit(rootPath, url);
  });

  return function clone(_x8, _x9) {
    return _ref8.apply(this, arguments);
  };
}();

const getPaths =
/*#__PURE__*/
function () {
  var _ref9 = (0, _asyncToGenerator2.default)(function* (starterPath, rootPath) {
    let selectedOtherStarter = false; // if no args are passed, prompt user for path and starter

    if (!starterPath && !rootPath) {
      const response = yield _prompts.default.prompt([{
        type: `text`,
        name: `path`,
        message: `What is your project called?`,
        initial: `my-gatsby-project`
      }, {
        type: `select`,
        name: `starter`,
        message: `What starter would you like to use?`,
        choices: [{
          title: `gatsby-starter-default`,
          value: `gatsby-starter-default`
        }, {
          title: `gatsby-starter-hello-world`,
          value: `gatsby-starter-hello-world`
        }, {
          title: `gatsby-starter-blog`,
          value: `gatsby-starter-blog`
        }, {
          title: `(Use a different starter)`,
          value: `different`
        }],
        initial: 0
      }]); // exit gracefully if responses aren't provided

      if (!response.starter || !response.path.trim()) {
        throw new Error(`Please mention both starter package and project name along with path(if its not in the root)`);
      }

      selectedOtherStarter = response.starter === `different`;
      starterPath = `gatsbyjs/${response.starter}`;
      rootPath = response.path;
    } // set defaults if no root or starter has been set yet


    rootPath = rootPath || process.cwd();
    starterPath = starterPath || `gatsbyjs/gatsby-starter-default`;
    return {
      starterPath,
      rootPath,
      selectedOtherStarter
    };
  });

  return function getPaths(_x10, _x11) {
    return _ref9.apply(this, arguments);
  };
}();

const successMessage = path => {
  _reporter.default.info(`
Your new Gatsby site has been successfully bootstrapped. Start developing it by running:

  cd ${path}
  gatsby develop
`);
};
/**
 * Main function that clones or copies the starter.
 */


function initStarter(_x12, _x13) {
  return _initStarter.apply(this, arguments);
}

function _initStarter() {
  _initStarter = (0, _asyncToGenerator2.default)(function* (starter, options) {
    const _ref10 = yield getPaths(starter, options.rootPath),
          starterPath = _ref10.starterPath,
          rootPath = _ref10.rootPath,
          selectedOtherStarter = _ref10.selectedOtherStarter;

    const urlObject = _url.default.parse(rootPath);

    if (selectedOtherStarter) {
      _reporter.default.info(`Opening the starter library at https://gatsby.dev/starters?v=2...\nThe starter library has a variety of options for starters you can browse\n\nYou can then use the gatsby new command with the link to a repository of a starter you'd like to use, for example:\ngatsby new ${rootPath} https://github.com/gatsbyjs/gatsby-starter-default`);

      (0, _betterOpn.default)(`https://gatsby.dev/starters?v=2`);
      return;
    }

    if (urlObject.protocol && urlObject.host) {
      (0, _gatsbyTelemetry.trackError)(`NEW_PROJECT_NAME_MISSING`);
      const isStarterAUrl = starter && !_url.default.parse(starter).hostname && !_url.default.parse(starter).protocol;

      if (/gatsby-starter/gi.test(rootPath) && isStarterAUrl) {
        _reporter.default.panic({
          id: `11610`,
          context: {
            starter,
            rootPath
          }
        });

        return;
      }

      _reporter.default.panic({
        id: `11611`,
        context: {
          rootPath
        }
      });

      return;
    }

    if (!(0, _isValidPath.default)(rootPath)) {
      _reporter.default.panic({
        id: `11612`,
        context: {
          path: _path.default.resolve(rootPath)
        }
      });

      return;
    }

    if ((0, _fsExistsCached.sync)(_path.default.join(rootPath, `package.json`))) {
      (0, _gatsbyTelemetry.trackError)(`NEW_PROJECT_IS_NPM_PROJECT`);

      _reporter.default.panic({
        id: `11613`,
        context: {
          rootPath
        }
      });

      return;
    }

    const hostedInfo = _hostedGitInfo.default.fromUrl(starterPath);

    (0, _gatsbyTelemetry.trackCli)(`NEW_PROJECT`, {
      starterName: hostedInfo ? hostedInfo.shortcut() : `local:starter`
    });
    if (hostedInfo) yield clone(hostedInfo, rootPath);else yield copy(starterPath, rootPath);
    successMessage(rootPath);
    (0, _gatsbyTelemetry.trackCli)(`NEW_PROJECT_END`);
  });
  return _initStarter.apply(this, arguments);
}